# Ознакомление с JPA Criteria API, Query DSL, Jooq
## Поверхностное ознакомление с каждой из технологий
**JPA Criteria API**:
-   Это API, предоставляемое спецификацией JPA для динамического построения запросов.
-   Запросы создаются программно, что делает их типобезопасными и гибкими для различных сценариев.
-   Хорошо интегрируется с Hibernate и другими реализациями JPA.

**QueryDSL**:
-   Это библиотека для создания запросов с использованием Java DSL.
-   Поддерживает различные источники данных: SQL, MongoDB, Lucene и др.
-   Запросы типобезопасны и выглядят более читаемыми по сравнению с JPA Criteria API.

**Jooq**:
-   Это библиотека для работы с SQL, которая генерирует классы из схемы базы данных.
-   Позволяет писать запросы на SQL напрямую, но с использованием Java DSL.
-   Считается более продвинутой в работе с SQL, чем QueryDSL и JPA.

## Сравнительный анализ
| Характеристика |JPA Criteria API|QueryDSL|Jooq
|--|--|--|--
|Поддержка JPA|Полная|Полная|Ограниченная
|Стиль запросов|Императивный|Декларативный DSL|DSL, близкий к SQL
|Читаемость|Низкая|Высокая|Высокая
|Типобезопасность|Да|Да|Да
|Простота интеграции|Легкая|Легкая с JPA, сложнее с SQL|Требует генерации классов
|Поддержка разных БД|Только JPA|SQL, MongoDB и др.|SQL
|Уровень контроля над SQL|Низкий|Средний|Высокий
|Продуктивность в больших проектах|Средняя|Высокая|Очень высокая

### Поддержка JPA
#### **JPA Criteria API и QueryDSL: Полная поддержка JPA**
|Технология|Интеграция с JPA|Интеграция с SQL|Основные сложности
|--|--|--|--
|JPA Criteria API|Легкая (встроенная в JPA)|Нет интеграции с SQL напрямую|Менее читаемый императивный стиль
|QueryDSL|Легкая, но требует генерации метамоделей|Сложнее с чистым SQL|Требует генерации Q-классов, сложнее с чистым SQL
|Jooq|Сложная интеграция с JPA|Легкая интеграция с SQL|Требует генерации классов на основе схемы БД

**JPA Criteria API** и **QueryDSL** созданы специально для работы с JPA, и их API полностью интегрированы с JPA, предоставляя возможность работать с объектами, управляемыми JPA (сущностями), и использовать преимущества ORM (object-relational mapping). Основные причины, почему эти технологии предлагают полную поддержку JPA:

-   **JPA Criteria API** — часть спецификации JPA. Это означает, что оно интегрировано на уровне спецификации и полностью поддерживает все возможности JPA: ленивую загрузку данных, управление сущностями, кэширование, работу с транзакциями, и многие другие особенности JPA.
    
-   **QueryDSL** предлагает более удобный и читаемый способ построения запросов, чем JPA Criteria API, но также имеет полную интеграцию с JPA через модуль QueryDSL JPA. QueryDSL использует аннотации JPA для генерации метамоделей (Q-классов) и работы с объектами JPA. Все его запросы тесно интегрированы с сущностями и жизненным циклом JPA.
    

#### **Jooq: Ограниченная поддержка JPA**

**Jooq** ориентирован на работу с чистым SQL, а не с ORM или объектами JPA. Он использует подход "SQL first", то есть акцент делается на управление SQL-запросами, а не на управление объектами в памяти, как это делает JPA. Причины ограниченной поддержки JPA в Jooq:

-   **Философия SQL-ориентированного подхода**: Jooq не создавался как инструмент для работы с объектами и их маппинга в базу данных (что делает JPA). Вместо этого Jooq позволяет писать типобезопасные запросы на уровне SQL, сохраняя полную мощь и гибкость SQL. В то время как JPA скрывает SQL-запросы за слоем абстракции, Jooq напротив, позволяет полностью контролировать SQL, не привязываясь к объектам JPA.
    
-   **Нет прямой интеграции с ORM**: Jooq не управляет сущностями и их состоянием так, как это делает JPA. Он не обрабатывает такие вещи, как кэширование, ленивую загрузку или другие аспекты работы с объектами в JPA. Это означает, что если нужно использовать Jooq в проекте с JPA, разработчику придется самому управлять интеграцией между сущностями JPA и чистыми SQL-запросами Jooq. Поэтому поддержка JPA ограничена — Jooq не может автоматически работать с жизненным циклом сущностей, управлять кэшами или учитывать правила, касающиеся ассоциаций и транзакций, специфичных для JPA.
    
-   **Прямой доступ к таблицам**: Jooq генерирует классы на основе схемы базы данных (таблиц и полей), а не на основе JPA-сущностей. Это означает, что он работает напрямую с таблицами и колонками, а не с объектами. Если используются JPA-сущности, придется явно указывать связи между Jooq и JPA, что добавляет сложности в интеграцию.
    

#### **Когда использовать Jooq с JPA?**

В проектах, где требуется большая гибкость и контроль над SQL-запросами, Jooq может быть полезен, но в таком случае его часто используют вместе с JPA. Например, для сложных запросов, которые трудно или неэффективно реализовать через JPA, Jooq может быть использован для написания сложного SQL, в то время как JPA продолжает управлять состоянием объектов.

Для этого разработчики могут:

-   Использовать Jooq для выполнения сложных SQL-запросов, особенно если необходимы специфические SQL-функции, поддерживаемые только в SQL.
    
-   Оставить JPA для управления сущностями, кэшированием и ленивой загрузкой данных.
    

Однако нужно помнить, что работа с Jooq в контексте JPA потребует больше ручного управления.

#### **Заключение**

-   **JPA Criteria API** и **QueryDSL** полностью поддерживают JPA, потому что они созданы для работы с объектами и абстрагируются от SQL, фокусируясь на маппинге объектов в базу данных.
    

**Jooq**, с другой стороны, предоставляет прямой доступ к SQL, что ограничивает его интеграцию с JPA, так как его основная цель — работа с SQL, а не с объектами.

### **Стиль запросов**
#### **Императивный стиль (JPA Criteria API)**
Императивный стиль запросов предполагает пошаговое построение запросов с использованием методов и объектов программирования. Этот стиль требует от разработчика подробно описать каждый шаг создания запроса, так как он контролирует процесс напрямую. Примером императивного подхода является **JPA Criteria API**.

-   **Программирование с использованием JPA Criteria API**: запросы в JPA Criteria API строятся через создание объектов и вызов методов для каждого шага запроса. Этот стиль считается менее читаемым, поскольку включает в себя сложные цепочки методов и объектов, что делает код громоздким.
    

#### **Пример запроса в JPA Criteria API:**

    CriteriaBuilder cb = entityManager.getCriteriaBuilder(); 
    CriteriaQuery<User> query = cb.createQuery(User.class); 
    Root<User> user = query.from(User.class);
    Predicate agePredicate = cb.gt(user.get("age"), 30);
    query.select(user).where(agePredicate);
    List<User> users = entityManager.createQuery(query).getResultList();

В этом примере каждое действие — это явное указание на создание отдельных объектов CriteriaBuilder, CriteriaQuery, Predicate и т.д. Вы создаете запрос шаг за шагом, как бы "строите его вручную", что напоминает императивный стиль программирования.

**Преимущества**:
    
-   Гибкость в создании динамических запросов.
    
-   Легкость в модификации запроса по частям.
    
**Недостатки**:
    
-   Код становится менее читаемым, особенно для сложных запросов.
    
-   Требует явного управления каждым элементом запроса.
    

#### **Декларативный DSL (QueryDSL)**

**DSL (Domain-Specific Language)** — это "язык, специфичный для предметной области", который предоставляет разработчику более высокоуровневые, декларативные средства для работы с запросами. Декларативный стиль, такой как в **QueryDSL**, позволяет описывать запросы на более высоком уровне, акцентируя внимание на том, "что" мы хотим получить, а не на том, "как" это сделать.

-   **QueryDSL**: предоставляет более читаемый и декларативный API, чем JPA Criteria API, благодаря языковым конструкциям, которые позволяют писать типобезопасные запросы в виде DSL. При этом код выглядит более естественным для восприятия и чтения, так как ближе по структуре к обычным SQL-запросам, но с типовой безопасностью на уровне Java.
    

#### **Пример запроса в QueryDSL:**

    QUser user = QUser.user;
    List<User> users = queryFactory.selectFrom(user)
				   .where(user.age.gt(30))
				   .fetch();

В этом примере видно, что запрос строится декларативно: вы описываете **"что"** вы хотите (например, выбрать пользователей старше 30 лет), и QueryDSL на фоне генерирует SQL-запросы.

**Преимущества**:
    
-   Код более читаем и интуитивен.
    
-   DSL позволяет проще описывать запросы с типовой безопасностью.
    
**Недостатки**:
    
-   Не столь гибкий, как JPA Criteria API в некоторых сложных случаях.
    

#### **DSL, близкий к SQL (Jooq)**

**Jooq** использует DSL, который очень близок к чистому SQL, но представлен в виде объектно-ориентированного кода на Java. Это делает Jooq уникальным среди других решений, так как его DSL напрямую отражает структуру SQL-запросов.

-   **Стиль Jooq**: Jooq позволяет писать запросы, которые выглядят почти как обычный SQL, но с типовой безопасностью и в контексте Java. Например, select, from, where, join и другие ключевые SQL-конструкции представлены как методы библиотеки.
    

#### **Пример запроса в Jooq:**

    List<User> users = context.selectFrom(USER)
			      .where(USER.AGE.gt(30))
			      .fetch();

Этот код почти идентичен традиционному SQL, что делает его очень удобным для разработчиков, привыкших к SQL-запросам. Jooq позволяет разрабатывать сложные SQL-запросы, используя все возможности реляционной базы данных, такие как агрегации, оконные функции, подзапросы и другие возможности SQL.

**Преимущества**:
    
-   Максимальная гибкость и контроль над SQL-запросами.
    
-   Возможность использования всех специфичных SQL-функций, которые не всегда доступны через JPA.
    
-   Код очень похож на SQL, что упрощает работу с запросами для тех, кто хорошо знает SQL.
    
**Недостатки**:
    
-   Работает с уровня SQL, а не объектов. При использовании JPA требуется больше усилий для работы с объектами.
    

#### **Заключение**

-   **Императивный стиль (JPA Criteria API)** требует явного построения запроса шаг за шагом. Он гибкий, но может быть менее читаемым и сложным для восприятия.
    
-   **Декларативный стиль (QueryDSL)** позволяет более интуитивно и кратко описывать запросы, предоставляя высокоуровневый DSL, который абстрагирует часть сложности, сохраняя при этом типобезопасность.
    
-   **DSL, близкий к SQL (Jooq)** предоставляет наиболее естественный способ писать SQL-запросы в Java, предоставляя максимальный контроль и точность при работе с базами данных, однако менее интегрирован с JPA и ORM, чем другие подходы.

### Типобезопасность
**Типобезопасность** (или **type safety**) — это свойство системы программирования, при котором ошибки, связанные с типами данных, выявляются на этапе компиляции, а не во время выполнения программы. Это означает, что компилятор проверяет, что все значения и выражения имеют ожидаемые типы данных, и гарантирует, что данные одного типа не будут использоваться как данные другого типа без явного преобразования.

#### **Примеры типобезопасности в контексте запросов и программирования:**

**Типобезопасные запросы**: В системах, где есть типобезопасность, программисту не нужно беспокоиться о неправильном использовании типов данных (например, чисел как строк или наоборот). Если вы попытаетесь передать неподходящий тип данных в метод или оператор, система отловит ошибку на этапе компиляции, а не на этапе выполнения программы.

Например, в SQL-запросе на уровне строки (например, с использованием чистого SQL), вы можете случайно допустить ошибку, передав строку в место, где ожидается число. Это может вызвать ошибки на этапе выполнения, которые труднее отлаживать. В типобезопасных DSL (как QueryDSL или Jooq), такие ошибки будут предотвращены компилятором.

**Пример типобезопасного кода (QueryDSL)**:

В **QueryDSL** каждый запрос строится на основе генерированных классов, которые соответствуют сущностям базы данных. Эти классы содержат поля и методы, строго соответствующие типам данных.

Например, если в базе данных есть поле age с типом int, QueryDSL автоматически создаст поле в метамодели с таким же типом. Это означает, что вы не сможете случайно сравнить age с String, так как это вызовет ошибку компиляции.

**Корректный типобезопасный запрос:** age - это int, 30 - тоже int 

    QUser user = QUser.user;
    List<User> users = queryFactory.selectFrom(user)
				   .where(user.age.gt(30))
				   .fetch();

**НЕКОРРЕКТНЫЙ код:** age - это int, а "thirty" - String. Ошибка компиляции.

    List<User> users = queryFactory.selectFrom(user) 
    				   .where(user.age.eq("thirty"))
    				   .fetch();

Здесь QueryDSL не позволит вам выполнить запрос с неверным типом данных (например, сравнить int с String), и ошибка будет поймана на этапе компиляции.

**Отсутствие типобезопасности (чистый SQL)**:

В обычных SQL-запросах, которые передаются как строки в коде, типобезопасность отсутствует. Вы можете написать запрос с неправильными типами данных (например, сравнить строку с числом), и эта ошибка не будет обнаружена, пока запрос не выполнится. Ошибки выявляются только на этапе выполнения программы.

Пример ошибки без типобезопасности:

    String query = "SELECT * FROM user WHERE age > '30'"; 
    // Ошибка: age — это число, а '30' — строка

Ошибка в этом случае не будет обнаружена компилятором и приведет к ошибке на этапе выполнения программы.

#### **Преимущества типобезопасности:**
1.  **Раннее обнаружение ошибок**: Ошибки, связанные с несовместимыми типами данных, выявляются на этапе компиляции, что значительно сокращает вероятность багов в рантайме.
    
2.  **Упрощенная отладка**: Поскольку ошибки обнаруживаются до выполнения программы, их легче отловить и исправить, чем в случае, если они проявляются только при запуске программы.
    
3.  **Повышенная безопасность и надежность кода**: Программисты меньше рискуют допустить ошибки, связанные с неверными типами данных, что делает код более стабильным и предсказуемым.
    
4.  **Улучшенная читаемость и сопровождение кода**: Типобезопасные системы делают код более явным и понятным. Когда типы данных очевидны, легче поддерживать и изменять код.

### Уровень контроля над SQL и продуктивность в больших проектах

Эти две характеристики — **уровень контроля над SQL** и **продуктивность в больших проектах** — взаимосвязаны, особенно в зависимости от требований к системе, сложности SQL-запросов и размера проекта. Рассмотрим, как эти аспекты соотносятся для **JPA Criteria API**, **QueryDSL** и **Jooq**.

#### **JPA Criteria API**

#### Уровень контроля над SQL: Низкий

JPA Criteria API предоставляет ограниченный контроль над SQL-запросами, потому что это высокоуровневая абстракция, ориентированная на работу с объектами, а не на управление SQL напрямую. JPA скрывает от разработчика все аспекты SQL, и вместо этого управляет объектами Java (сущностями). Это означает, что запросы строятся в объектно-ориентированном стиле, и конкретная структура SQL-запросов, генерируемых JPA, не всегда контролируема.

-   **Особенности**:
    
    -   SQL-запросы автоматически генерируются на основе сущностей и их взаимосвязей.
    -   Ограниченный доступ к специфическим функциям и возможностям SQL (например, оконные функции, сложные соединения и подзапросы).
    -   Проблемы оптимизации SQL-запросов могут возникнуть, особенно при работе с большими и сложными базами данных.
-   **Пример**: Когда вы используете `CriteriaBuilder` для построения запроса, вы не видите фактический SQL, который будет выполнен, и не можете точно контролировать его структуру или оптимизировать запрос под конкретную СУБД.
    

#### Продуктивность в больших проектах: Средняя

JPA Criteria API предлагает хорошую интеграцию в небольших и средних проектах с типичными CRUD-операциями. Однако в больших проектах, где требуется больше гибкости и контроля над SQL, JPA может стать ограничением из-за своей абстракции и сложности работы с нестандартными запросами.

-   **Особенности**:
    -   Простота в создании стандартных запросов, но сложность в написании сложных запросов.
    -   Запросы могут стать менее производительными, если система автоматически генерирует неоптимальный SQL.

#### **QueryDSL**

#### Уровень контроля над SQL: Средний

**QueryDSL** предоставляет средний уровень контроля над SQL. В QueryDSL можно создавать сложные запросы, которые больше напоминают SQL, но при этом остаются типобезопасными и декларативными. Однако QueryDSL по-прежнему абстрагирует часть деталей SQL, особенно если используется вместе с JPA.

-   **Особенности**:
    
    -   QueryDSL позволяет более тонко контролировать запросы по сравнению с JPA Criteria API, особенно если вы используете его напрямую с SQL.
    -   При использовании QueryDSL с JPA запросы все равно абстрагируются через уровень ORM, что ограничивает полный контроль над SQL.
    -   С помощью QueryDSL SQL можно использовать специфические для СУБД функции, но это потребует немного больше ручной работы.
-   **Пример**: Вы можете писать запросы, такие как `selectFrom(user).where(user.age.gt(30))`, что даёт больше гибкости и читабельности, но SQL-контроль все равно остаётся частично скрытым за абстракцией.
    

#### Продуктивность в больших проектах: Высокая

В больших проектах QueryDSL обеспечивает значительное улучшение продуктивности благодаря своей типобезопасной и декларативной природе. Запросы легче поддерживать, легче расширять, и они менее склонны к ошибкам, связанным с типами.

-   **Особенности**:
    -   QueryDSL упрощает работу с динамическими запросами и сложной бизнес-логикой.
    -   Декларативный стиль позволяет разработчикам легко строить сложные запросы без необходимости писать длинные императивные конструкции, как в JPA Criteria API.
    -   В больших проектах QueryDSL обеспечивает более высокую продуктивность, так как его синтаксис читабельнее, чем JPA Criteria API, и позволяет легче управлять сложными запросами.

#### **Jooq**

#### Уровень контроля над SQL: Высокий

**Jooq** предоставляет максимальный уровень контроля над SQL-запросами, поскольку он позволяет писать запросы, которые почти идентичны SQL, но с типовой безопасностью и на уровне Java. Jooq генерирует Java-классы, отражающие таблицы и колонки базы данных, что позволяет разработчикам напрямую работать с SQL, сохраняя полный контроль над тем, как выполняются запросы.

-   **Особенности**:
    
    -   Полный контроль над SQL: вы можете использовать любые SQL-конструкции, включая специфические для конкретной СУБД функции, такие как оконные функции, объединения, агрегации, и т.д.
    -   Jooq позволяет писать и выполнять сложные, специфические SQL-запросы, которые нельзя легко выразить через JPA или QueryDSL.
    -   Jooq генерирует Java-классы на основе схемы базы данных, что позволяет создавать запросы в виде Java-кода, который полностью отражает структуру SQL.
-   **Пример**: Запрос в Jooq выглядит так же, как и в SQL:
    `create.selectFrom(USER).where(USER.AGE.gt(30)).fetch();` 
    Это фактически SQL-запрос, который управляется через Java, и вы полностью контролируете его структуру.
    

#### Продуктивность в больших проектах: Очень высокая

Jooq обеспечивает очень высокую продуктивность в больших проектах, особенно там, где требуется сложная работа с SQL. В крупных проектах, где важны производительность, оптимизация запросов и использование специфических для СУБД функций, Jooq становится незаменимым инструментом.

-   **Особенности**:
    -   Продуктивность значительно выше, чем у JPA и QueryDSL, если проект сильно завязан на работу с SQL.
    -   Легче поддерживать и оптимизировать SQL-запросы, что делает Jooq идеальным инструментом для проектов с высокими требованиями к производительности и сложными схемами баз данных.
    -   Несмотря на высокую продуктивность при работе с SQL, Jooq может быть менее удобен, если проект требует использования ORM (например, JPA), поскольку он не поддерживает управление объектами, как JPA.

## Углубление в одну из технологий

Наиболее актуальной для тебя технологией может стать **Jooq**, если тебе нужно больше контроля над SQL и ты работаешь с реляционными базами данных. Она позволяет строить сложные SQL-запросы с минимальными усилиями, но требует некоторой начальной настройки для генерации классов.

Если проект сильно зависит от JPA и ORM, то **QueryDSL** может быть хорошим компромиссом между JPA Criteria и Jooq, предлагая больше гибкости и читаемости при сохранении типобезопасности.
